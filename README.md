# FlowSync: A Multi-Agent Deep Reinforcement Learning Framework for Adaptive Traffic Signal Optimization

**FlowSync** is an advanced, multi-agent deep reinforcement learning (MARL) framework designed to optimize urban traffic signal control. This project evolves the single-agent concepts from **IntelliLight** into a fully coordinated, multi-intersection network.

The core of this framework is an **Attention-Based** neural network, which allows each traffic signal agent to intelligently weigh the state of its neighbors before making a decision. This enables complex, coordinated behavior to reduce congestion across an entire grid.

This implementation is built in Python, uses Keras (TensorFlow) for its neural networks, and interfaces directly with the **SUMO (Simulation of Urban MObility)** traffic simulator.

## Learning in Action: 2x2 Grid Visualization

The following graph was generated by this framework after training four agents on a 2x2 grid map. The clear upward trend shows that all four agents are successfully learning to reduce penalties (like wait time and queue length) by coordinating their actions.

## Key Features

  * **Multi-Agent Coordination:** Deploys a separate, autonomous Deep Q-Network (DQN) agent for each intersection, managed by a central synchronous coordinator (`traffic_light_dqn.py`).
  * **Neighbor-State Attention:** The agent's "brain" (`deeplight_agent.py`) uses an attention mechanism to analyze data from neighboring intersections (their queue lengths and current phases), allowing it to make context-aware decisions.
  * **Hierarchical State Representation:** The `State` object (`agent.py`) combines a local 2D "map" of vehicle positions, 1D vectors for local queues, and 2D vectors for all neighbor states.
  * **Dynamic Network Discovery:** The `map_computor.py` script automatically discovers all traffic light junctions and their topological neighbors (e.g., `J1` is a neighbor of `J2`) directly from the SUMO `.net.xml` file at runtime.
  * **Configurable Scenarios:** Easily switch between a simple single intersection (`one_run`) and a complex 2x2 grid (`grid_2x2`) by changing one variable.
  * **Visualization Utility:** A `plot_results.py` script is included to automatically parse the `memories.txt` log file and generate a professional, smoothed learning curve to prove agent performance.

## Project Structure

```
FlowSync/
│
├── runexp.py               # Main script to launch the experiment
├── traffic_light_dqn.py    # The central Multi-Agent Coordinator
├── deeplight_agent.py      # The Agent's "brain" (holds the NN model with Attention)
├── network_agent.py        # Base class for neural network agents
├── sumo_agent.py           # Defines the State/Action interface for a single agent
├── map_computor.py         # Low-level functions for interacting with the SUMO/TraCI API
├── agent.py                # Base class for the Agent and State
├── plot_results.py         # Utility to visualize the learning curve from logs
│
├── conf/
│   ├── one_run/            # Configs for the original single-intersection map
│   └── grid_2x2/           # Configs for the 2x2 multi-agent map
│       ├── exp.conf
│       └── sumo_agent.conf
│
├── data/
│   ├── one_run/
│   └── grid_2x2/           # SUMO files for the 2x2 multi-agent map
│       ├── grid.net.xml    # (Generated by netconvert)
│       ├── grid.nod.xml
│       ├── grid.edg.xml
│       ├── grid.rou.xml    # (Balanced traffic flows for all 4 agents)
│       └── grid.sumocfg
│
└── records/                # (Generated) Log files and rewards
    └── grid_2x2/
        └── <experiment_name>/
            └── memories.txt
```

## How to Run

### 1\. Prerequisites

  * Python 3.10+

  * **SUMO (Simulation of Urban MObility):** The SUMO simulation suite must be installed.

  * **Python Libraries:** This project requires Keras 3 (TensorFlow), Pandas, and Matplotlib.

    ```bash
    pip install tensorflow numpy traci pandas matplotlib
    ```

### 2\. Step-by-Step Guide

1.  **Configure SUMO Path:**
    Open `runexp.py` and modify the `sumoBinary_gui` and `sumoBinary_nogui` variables to point to the correct path of `sumo-gui.exe` and `sumo.exe` on your system (e.g., `C:\Program Files (x86)\Eclipse\Sumo\bin\sumo-gui.exe`).

2.  **Choose Your Experiment:**
    Open `runexp.py` and set the `setting_memo` variable (line 18) to the experiment you want to run:

      * **Multi-Agent (Recommended):** `setting_memo = "grid_2x2"`
      * **Single-Agent (Test):** `setting_memo = "one_run"`

3.  **Generate 2x2 Map File (First-Time-Only):**
    If running `grid_2x2` for the first time, you must generate the `.net.xml` file.

      * Open a terminal and navigate to the `data/grid_2x2/` folder.
      * Run the SUMO `netconvert` tool:
        ```bash
        netconvert --node-files=grid.nod.xml --edge-files=grid.edg.xml --output-file=grid.net.xml
        ```

4.  **Configure Experiment Length:**
    Open `conf/grid_2x2/exp.conf`. This file controls the experiment's duration.

      * `"RUN_COUNTS"`: Total simulation seconds for training. A short test is `5000`. A full run to show learning should be `36000` or more.
      * `"RUN_COUNTS_PRETRAIN"`: Duration for the pre-training phase.

5.  **Run Training:**
    Execute the main launcher script from your terminal:

    ```bash
    python runexp.py
    ```

      * **Note:** For the fastest training, make sure `runexp.py` (line 95) is set to `sumo_cmd_str=sumoCmd_nogui`. To watch the simulation, change this to `sumoCmd_str=sumoCmd`.

### 3\. Visualize Your Results

After the training script finishes, run the plotting utility to generate your learning curve:

```bash
python plot_results.py
```

This will automatically find the latest `memories.txt` log file in the `records/` directory, process it, and save the final graph as **`learning_curve.png`** in your main folder. This plot is the final proof that your agents are learning.
